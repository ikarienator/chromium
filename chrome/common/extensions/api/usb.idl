// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

namespace usb {

  // Direction, Recipient, RequestType, and TransferType all map to their
  // namesakes within the USB specification.
  enum Direction {in, out};
  enum Recipient {device, _interface, endpoint, other};
  enum RequestType {standard, class, vendor, reserved};
  enum TransferType {control, interrupt, isochronous, bulk};

  // For isochronous mode, SynchronizationType and UsageType map to their
  // namesakes within the USB specification.
  enum SynchronizationType {asynchronous, adaptive, synchronous};
  enum UsageType {data, feedback, explicitFeedback};

  // A <code>Device</code> uniquely identifies a connected USB device.
  // They are returned by <code>getDevices</code> calls and the
  // <code>device</code> field remains consistent for the same device.
  dictionary Device {
    long device;
    long vendorId;
    long productId;
  };

  // A <code>DeviceHandle</code> encapsulates everything needed to communicate
  // with a USB device.
  // They are returned by <code>openDevice</code> calls.
  dictionary DeviceHandle {
    long handle;
    long vendorId;
    long productId;
  };

  dictionary EndpointDescriptor {
    long address;
    TransferType type;
    Direction direction;
    long maximumPacketSize;

    // Used for isochronous mode.
    SynchronizationType? synchronization;
    UsageType? usage;

    // If this is an interrupt endpoint, this will be 1-255
    long? pollingInterval;
  };

  dictionary InterfaceDescriptor {
    long interfaceNumber;
    long alternateSetting;
    long interfaceClass;
    long interfaceSubclass;
    long interfaceProtocol;
    DOMString? description;
    EndpointDescriptor[] endpoints;
  };

  // ControlTransferInfo represents that parameters to a single USB control
  // transfer.
  dictionary ControlTransferInfo {
    // The direction of this transfer.
    Direction direction;

    // The intended recipient for this transfer.
    Recipient recipient;

    // The type of this request.
    RequestType requestType;

    long request;
    long value;
    long index;

    // If this transfer is an input transfer, then this field must be set to
    // indicate the expected data length. If this is an output transfer, then
    // this field is ignored.
    long? length;

    // The data payload carried by this transfer. If this is an output tranfer
    // then this field must be set.
    ArrayBuffer? data;
  };

  // GenericTransferInfo is used by both bulk and interrupt transfers to
  // specify the parameters of the transfer.
  dictionary GenericTransferInfo {
    // The direction of this transfer.
    Direction direction;

    long endpoint;

    // If this is an input transfer then this field indicates the size of the
    // input buffer. If this is an output transfer then this field is ignored.
    long? length;

    // If this is an output transfer then this field must be populated.
    // Otherwise, it will be ignored.
    ArrayBuffer? data;
  };

  // IsochronousTransferInfo describes a single multi-packet isochronous
  // transfer.
  dictionary IsochronousTransferInfo {
    // All of the normal transfer parameters are encapsulated in the
    // transferInfo parameters. Note that the data specified in this parameter
    // block is split along packetLength boundaries to form the individual
    // packets of the transfer.
    GenericTransferInfo transferInfo;

    // The total number of packets in this transfer.
    long packets;

    // The length of each of the packets in this transfer.
    long packetLength;
  };

  dictionary TransferResultInfo {
    // A value of 0 indicates that the transfer was a success. Other values
    // indicate failure.
    long? resultCode;

    // If the transfer was an input transfer then this field will contain all
    // of the input data requested.
    ArrayBuffer? data;
  };

  // GetDevicesOptions describes the properties of devices which are found and
  // opened via getDevices.
  dictionary GetDevicesOptions {
    long vendorId;
    long productId;
    long? interfaceId;
  };

  callback VoidCallback = void ();
  callback GetDevicesCallback = void (Device[] devices);
  callback FindDevicesCallback = void (DeviceHandle[] handles);
  callback OpenDeviceCallback = void (DeviceHandle handle);
  callback ListInterfacesCallback = void (InterfaceDescriptor[] descriptors);
  callback CloseDeviceCallback = void ();
  callback TransferCallback = void (TransferResultInfo info);
  callback ResetDeviceCallback = void(boolean result);

  interface Functions {
    // Get all instances of the USB devices specified by the vendorId/
    // productId pair.
    //
    // Upon successfully enumeration, the callback will be called with an array
    // of <code>Device</code> objects. <code>Device</code> objects can further 
    // be opened by <code>openDevice</code> before any communication takes
    // place.
    //
    // |options|: The properties to search for on target devices.
    // |callback|: Invoked after the enumeration completes.
    static void getDevices(GetDevicesOptions options,
                           GetDevicesCallback callback);

    // Open all instances of the USB devices specified by the vendorId/
    // productId pair.
    //
    // Upon successfully enumeration, the callback will be called with an array
    // of <code>DeviceHandle</code> objects. Developer is responsible to call
    // <code>closeDevice</code> on every <code>DeviceHandle</code>, otherwise
    // the USB device will not be closed even if the app not long possess any
    // reference to the <code>DeviceHanlde</code> object.
    //
    // |options|: The properties to search for on target devices.
    // |callback|: Invoked after the enumeration completes.
    static void findDevices(GetDevicesOptions options,
                            FindDevicesCallback callback);

    // Create a <code>DeviceHandle</code> for further operations.
    //
    // Multiple <code>DeviceHandle</code>s can be created for a same USB Device
    // and it is possible to use those handles independently with the device
    // support.
    //
    // Developers are responsible to call <code>closeDevice</code> to close
    // the handle, otherwise the device handle will not be closed even if there
    // is no reference to the <code>DeviceHandle</code> object.
    // |device|: The device to be opened.
    // |callback|: Invoked with the created <code>DeviceHandle</code>.
    static void openDevice(Device device,
                           OpenDeviceCallback callback);

    // Closes an device handle. This operation does not effect other handles
    // of the same device.
    // |handle|: The device handle to close.
    // |callback|: The callback to invoke once the device is closed.
    static void closeDevice(DeviceHandle handle,
        optional CloseDeviceCallback callback);

    // Lists all the interfaces on the USB device.
    // |handle|: The handle of the device from which the interfaces should be
    // listed.
    // |callback|: The callback to invoke when the interfaces are enumerated.
    static void listInterfaces(DeviceHandle handle,
        ListInterfacesCallback callback);

    // Claims an interface on the specified USB device.
    // |device|: The device on which the interface is to be claimed.
    // |interface|: The interface number to be claimed.
    // |callback|: The callback to invoke once the interface is claimed.
    static void claimInterface(DeviceHandle handle, long interfaceNumber,
        VoidCallback callback);

    // Releases a claim to an interface on the provided device.
    // |handle|: The handle of the device on which the interface is to be
    // released.
    // |interface|: The interface number to be released.
    // |callback|: The callback to invoke once the interface is released.
    static void releaseInterface(DeviceHandle handle, long interfaceNumber,
        VoidCallback callback);

    // Selects an alternate setting on a previously claimed interface on a
    // device.
    // |handle|: The handle of the device on which the interface settings are
    // to be set.
    // |interface|: The interface number to be set.
    // |alternateSetting|: The alternate setting to set.
    // |callback|: The callback to invoke once the interface setting is set.
    static void setInterfaceAlternateSetting(DeviceHandle handle,
        long interfaceNumber, long alternateSetting, VoidCallback callback);

    // Performs a control transfer on the specified device. See the
    // ControlTransferInfo structure for the parameters required to make a
    // transfer.
    // |handle|: An device handle to make the transfer on.
    // |transferInfo|: The parameters to the transfer. See ControlTransferInfo.
    // |callback|: Invoked once the transfer has completed.
    static void controlTransfer(DeviceHandle handle,
        ControlTransferInfo transferInfo, TransferCallback callback);

    // Performs a bulk transfer on the specified device.
    // |handle|: An device handle to make the transfer on.
    // |transferInfo|: The paramters to the transfer. See GenericTransferInfo.
    // |callback|: Invoked once the transfer has completed.
    static void bulkTransfer(DeviceHandle handle, GenericTransferInfo transferInfo,
        TransferCallback callback);

    // Performs an interrupt transfer on the specified device.
    // |handle|: An device handle to make the transfer on.
    // |transferInfo|: The paramters to the transfer. See GenericTransferInfo.
    // |callback|: Invoked once the transfer has completed.
    static void interruptTransfer(DeviceHandle handle,
        GenericTransferInfo transferInfo, TransferCallback callback);

    // Performs an isochronous transfer on the specific device.
    // |handle|: An device handle to make the transfer on.
    // |transferInfo|: The parameters to the transfer. See
    // IsochronousTransferInfo.
    // |callback|: Invoked once the transfer has been completed.
    static void isochronousTransfer(DeviceHandle handle,
        IsochronousTransferInfo transferInfo,
        TransferCallback callback);

    // Try to reset the USB device and restore the previous status.
    //
    // If the reset fails, the given device will be closed and the USB device
    // will appear to be disconected and reconnected.
    // You must call <code>findDevice</code> again to acquire the device.
    //
    // |handle|: An device handle to reset.
    // |callback|: Invoked once the device is reset with a boolean indicating
    // whether the reset is completed successfully.
    static void resetDevice(DeviceHandle handle,
        ResetDeviceCallback callback);
  };
};
