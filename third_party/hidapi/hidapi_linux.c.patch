diff --git a/third_party/hidapi/hidapi_linux.c b/third_party/hidapi/hidapi_linux.c
index 39181d9..c0df76f 100644
--- a/third_party/hidapi/hidapi_linux.c
+++ b/third_party/hidapi/hidapi_linux.c
@@ -83,6 +83,8 @@ static __u32 kernel_version = 0;
 static hid_device *new_hid_device(void)
 {
   hid_device *dev = calloc(1, sizeof(hid_device));
+  if (dev == NULL)
+    return NULL;
   dev->device_handle = -1;
   dev->blocking = 1;
   dev->uses_numbered_reports = 0;
@@ -102,6 +104,8 @@ static wchar_t *utf8_to_wchar_t(const char *utf8)
       return wcsdup(L"");
     }
     ret = calloc(wlen+1, sizeof(wchar_t));
+    if (ret == NULL)
+      return NULL;
     mbstowcs(ret, utf8, wlen+1);
     ret[wlen] = 0x0000;
   }
@@ -124,7 +128,7 @@ static int uses_numbered_reports(__u8 *report_descriptor, __u32 size) {
   int data_len, key_size;
 
   while (i < size) {
-    int key = report_descriptor[i];
+    __u8 key = report_descriptor[i];
 
     /* Check for the Report ID key */
     if (key == 0x85/*Report ID*/) {
@@ -267,6 +271,9 @@ static int get_device_string(hid_device *dev, enum device_string_id key, wchar_t
       int bus_type;
       size_t retm;
 
+      serial_number_utf8 = NULL;
+      product_name_utf8 = NULL;
+
       ret = parse_uevent_info(
         udev_device_get_sysattr_value(hid_dev, "uevent"),
         &bus_type,
@@ -275,6 +282,8 @@ static int get_device_string(hid_device *dev, enum device_string_id key, wchar_t
         &serial_number_utf8,
         &product_name_utf8);
 
+      if (!ret) goto end;
+
       if (bus_type == BUS_BLUETOOTH) {
         switch (key) {
           case DEVICE_STRING_MANUFACTURER:
@@ -282,11 +291,11 @@ static int get_device_string(hid_device *dev, enum device_string_id key, wchar_t
             ret = 0;
             break;
           case DEVICE_STRING_PRODUCT:
-            retm = mbstowcs(string, product_name_utf8, maxlen);
+            retm = mbstowcs(string, product_name_utf8, maxlen - 1);
             ret = (retm == (size_t)-1)? -1: 0;
             break;
           case DEVICE_STRING_SERIAL:
-            retm = mbstowcs(string, serial_number_utf8, maxlen);
+            retm = mbstowcs(string, serial_number_utf8, maxlen - 1);
             ret = (retm == (size_t)-1)? -1: 0;
             break;
           case DEVICE_STRING_COUNT:
@@ -305,7 +314,7 @@ static int get_device_string(hid_device *dev, enum device_string_id key, wchar_t
           const char *str;
           const char *key_str = NULL;
 
-          if (key >= 0 && key < DEVICE_STRING_COUNT) {
+          if (key < DEVICE_STRING_COUNT) {
             key_str = device_string_names[key];
           } else {
             ret = -1;
@@ -437,6 +446,10 @@ struct hid_device_info  HID_API_EXPORT *hid_enumerate(unsigned short vendor_id,
 
       /* VID/PID match. Create the record. */
       tmp = malloc(sizeof(struct hid_device_info));
+      if (tmp == NULL) {
+        goto next;
+      }
+
       if (cur_dev) {
         cur_dev->next = tmp;
       }
@@ -629,13 +642,13 @@ hid_device * HID_API_EXPORT hid_open_path(const char *path)
 
     /* Get Report Descriptor Size */
     res = ioctl(dev->device_handle, HIDIOCGRDESCSIZE, &desc_size);
-    if (res < 0)
+    if (res < 0) {
       perror("HIDIOCGRDESCSIZE");
-
-
+    } else {
       /* Get Report Descriptor */
       rpt_desc.size = desc_size;
       res = ioctl(dev->device_handle, HIDIOCGRDESC, &rpt_desc);
+
       if (res < 0) {
         perror("HIDIOCGRDESC");
       } else {
@@ -644,6 +657,7 @@ hid_device * HID_API_EXPORT hid_open_path(const char *path)
             uses_numbered_reports(rpt_desc.value,
                                   rpt_desc.size);
       }
+    }
 
     return dev;
   }
@@ -699,7 +713,7 @@ int HID_API_EXPORT hid_read_timeout(hid_device *dev, unsigned char *data, size_t
   if (bytes_read < 0 && (errno == EAGAIN || errno == EINPROGRESS))
     bytes_read = 0;
 
-  if (bytes_read >= 0 &&
+  if (bytes_read > 0 &&
       kernel_version < KERNEL_VERSION(2,6,34) &&
       dev->uses_numbered_reports) {
     /* Work around a kernel bug. Chop off the first byte. */
